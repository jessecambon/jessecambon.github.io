---
layout: post
title:  "Practical Tidy Evaluation"
date:   2019-12-8
tags: test
output: 
  md_document:
    variant: gfm
    preserve_yaml: TRUE
---

```{r setup, include=FALSE}
library(here)
source(here::here("rmd_config.R"))
```

[Tidy evaluation](https://tidyeval.tidyverse.org/) is a framework for controlling how expressions and variables in your code are evaluated by [tidyverse](https://www.tidyverse.org/) functions. This framework, housed in the [rlang package](https://rlang.r-lib.org), is a powerful tool for writing more efficient and modular tidyverse code. In particular, you'll find it useful for passing variable names as inputs to functions that use tidyverse packages like [dplyr](https://dplyr.tidyverse.org/) and [ggplot2](https://ggplot2.tidyverse.org/). 

The goal of this post is to offer accessible examples and intuition for putting tidy evaluation to work in your own code. Because of this, I will keep conceptual explanations brief, but for more comprehensive documentation you can refer to [rlang's website](https://rlang.r-lib.org/reference/), the ['Tidy Evaluation' book](https://tidyeval.tidyverse.org/) by Lionel Henry and Hadley Wickham, and the [Metaprogramming Section of the 'Advanced R' book](https://adv-r.hadley.nz/metaprogramming.html) by Hadley Wickham.

### Motivating Example

To begin, let's consider a basic analysis of the [mtcars dataset](https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/mtcars.html). Below we calculate maximum and minimum horsepower (hp) by the number of cylinders (cyl) using the [group_by](https://dplyr.tidyverse.org/reference/group_by.html) and [summarize](https://dplyr.tidyverse.org/reference/summarise.html) functions from [dplyr](https://dplyr.tidyverse.org/).

```{r,results=F,message=F}
library(dplyr)
hp_by_cyl <- mtcars %>% 
  group_by(cyl) %>%
  summarize(min_hp=min(hp),
            max_hp=max(hp))
```

```{r,echo=F}
kable(hp_by_cyl)
```

Now let's say we wanted to repeat this calculation multiple times while changing which variable we group by. A brute force method to accomplish this would be to copy and paste our code as many times as necessary and replace "cyl" with our new variable names. However that's inefficient especially if our code gets more complicated, requires many iterations, or will need to be updated frequently. 

To avoid this inelegant solution you might think to store the name of a variable inside of another variable like this `groupby_var <- "vs"`. Then you could attempt to use your newly created "groupby_var" variable in your code: `group_by(groupby_var)`. However, if you try this you will find it doesn't work. The "group_by" function expects the name of the variable you want to group by as an input, not the name of a variable that *contains* the name of the variable you want to group by. 

This is the kind of headache that tidy evaluation can help you remedy. In the example below we use the [quo](https://rlang.r-lib.org/reference/quotation.html) function and the "bang-bang" [!!](https://rlang.r-lib.org/reference/nse-force.html) operator to set "vs" (engine type, 0 = automatic, 1 = manual) as our group by variable. The "quo" function allows us to store the variable name in our "groupby_var" variable and "!!" extracts the stored variable name.

```{r,results=F,message=F}
groupby_var <- quo(vs)

hp_by_vs <- mtcars %>% 
  group_by(!!groupby_var) %>%
  summarize(min_hp=min(hp),
            max_hp=max(hp))
```

```{r,echo=F}
kable(hp_by_vs)
```

The code above provides a method for setting the group by variable by modifying the input to the "quo" function. This has some utility, particularly if we were referencing the group by variable multiple times. However, if we want to utilize a piece of code like this repeatedly in a script then we should consider packaging it into a function which is what we will do next.

### Making Functions with Tidy Evaluation

To use tidy evaluation in a function, we will still use the "!!" operator as we did above, but instead of "quo" we will use the  [enquo](https://rlang.r-lib.org/reference/nse-defuse.html) function. Our function takes the group by variable and the measurement variable as inputs so that we can now calculate maximum and minimum values of other variables. This function is defined below and used to group by "am" (transmission type, 0 = automatic, 1 = manual) and calculate summary statistics with the "hp" (horsepower) variable. Also note two additional features I have introduced with this function:

* The "walrus operator" [:=](https://rlang.r-lib.org/reference/quasiquotation.html#forcing-names) creates a variable named after the "measure_var" argument (hp in the example). The walrus operator is necessary because the variable we are evaluating with "!!" is now a column name instead of a column value.
* The [as_label](https://rlang.r-lib.org/reference/as_label.html) function extracts the string value of the "measure_var" variable. 



```{r,results=F,message=F}
car_stats <- function(groupby_var,measure_var) {
  groupby_var <- enquo(groupby_var)
  measure_var <- enquo(measure_var)
  return(mtcars %>% 
    group_by(!!groupby_var) %>%
    summarize(min=min(!!measure_var),
              max=max(!!measure_var)) %>%
          mutate(measure_var = as_label(measure_var),
            !!measure_var := NA) %>%
    select(!!groupby_var,measure_var,everything())
    )
}
hp_by_am <- car_stats(am,hp)
```

```{r,echo=F}
kable(hp_by_am)
```

Now we have a flexible function for utilizing a dplyr data analysis workflow. You can experiment with modifying this function for your own purposes. Also, as you might suspect, you could use the same tidy evaluation functions we used above with tidyverse packages other than dplyr. 

As an example, below I've defined a function that builds a scatter plot with [ggplot2](https://ggplot2.tidyverse.org/). The function takes  a dataset and two variable names as inputs. You will notice that the data argument needs no tidy evaluation. The [as_label](https://rlang.r-lib.org/reference/as_label.html) function is this time used to extract our variable names as strings to create a plot title with the "ggtitle" function. 

```{r, message=F}
library(ggplot2)
scatter_plot <- function(df,x_var,y_var) {
  x_var <- enquo(x_var)
  y_var <- enquo(y_var)
  
  return(ggplot(data=df,aes(x=!!x_var,y=!!y_var)) + 
  geom_point() + theme_bw() + 
  theme(plot.title = element_text(lineheight=1, face="bold",hjust = 0.5)) +
  geom_smooth() +
  ggtitle(str_c(as_label(y_var), " vs. ",as_label(x_var)))
  )
}
scatter_plot(mtcars,disp,hp)
```

As you can see, we've plotted the "hp" (horsepower) variable against "disp" (displacement) and added a regression line. Instead of copying and pasting ggplot code to create the same plot with different datasets and variables, we can just call our function. 

### The "Curly-Curly" Shortcut and Passing Multiple Variables

To wrap things up, I'll cover a few additional tricks for your tidy evaluation toolbox:

* The "curly-curly" {% raw %}[{{ }}](https://www.tidyverse.org/blog/2019/06/rlang-0-4-0/){% endraw %} operator is a shortcut which is used to directly extract a stored variable name from "measure_var" in the example below. In the prior example we needed both "enquo" and "!!" to do this. However, note that if you want to extract the string variable name with the "as_label" function, you will still need to use "enquo" and "!!" as we have done with "measure_name" below.
* The [syms](https://rlang.r-lib.org/reference/sym.html) function and the "!!!" operator are used for passing a list of variables as a function argument (we use this to pass multiple group by variables below). Because we are evaluating a list of variables, the "!!!" is now used for "groupby_vars" instead of the "!!" operator we have used previously. One quirk is that to use the "syms" function we will need to pass the variable names as strings (in quotes). 
* Created variables in the "summarize" function are named with a combination of the "measure_name" value and a string with the "!!" and ":=" operators and the "str_c" function from [stringr](https://stringr.tidyverse.org/). You can use similar code to build your own variable names with strings using functions such as summarize and mutate.

The function is defined below and used to group by the "cyl" variable and then by the "am" and "vs" variables (ie. the "!!!" operator and "syms" function can be used with either a list of strings or a single string)

```{r}
get_stats <- function(data,groupby_vars,measure_var) {
  groupby_vars <- syms(groupby_vars)
  measure_name <- as_label(enquo(measure_var))
  return( 
    data %>% group_by(!!!groupby_vars) %>%
            summarize( !!str_c(measure_name,"_min") := min({{measure_var}}),
                       !!str_c(measure_name,"_max") := max({{measure_var}}))
    )}
cyl_hp_stats <- mtcars %>% get_stats("cyl",mpg)
gear_stats <- mtcars %>% get_stats(c("am","vs"),gear)
```

```{r,echo=F}
kable(cyl_hp_stats)
kable(gear_stats)
```

This concludes my introduction to tidy evaluation. Hopefully this serves as a useful starting point for using these concepts in your own code.